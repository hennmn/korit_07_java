Array07 ~
# 금일 수업 계획
- 배열
  -  이중 배열 등
- 상속
- 추상화 (가능하다면)

# cord convention 관련

```java
import java.util.Scanner;

public class PersonMain {
    public static void main(String[] args) {
        // 사용할 외부 및 내부 클래스 목록들 전부 impot 해옴
        Scanner scanner = new Scanner(System.in);
        Array08 array08 = new Array08();
        //사용하는 변수 목록들 전부 선언
        int randomNum;
        double[] scores = new double[25];
        String[] students = new String[25];
        // ...
        // 내부 로직들 엄청나게 써놓고 있다고 가정하다가
        // 저 밑에서 갑자기
        // students가 튀어나왔다고 가정해보겠습니다.
        if(randomNum < 0)
        {
            // 이런 방식으로 실행문을 써야합니다. 라는 식으로 회사에서 정하는 경우가 있음
        }

    }
}
```
-----
### 향상된 for문(Enhanced For Loop)
일반 for문의 경우 index 넘버(주소지)를 명확하게 알고 있어야 하지만
일일이 element의 숫자를 세는 것이 번거롭기 때문에
arr01.length 와 같은 방식으로 일종의 field 참조를 통해 int 값을 추출하여
대입해야만 했습니다.

그런데 잘 생각해보면 for(int i = 0; /...) 부분에서 int 는
for문 내부에서 선언되고, 내부에서만 사용이 가능합니다.

이를 응용하여 배열 내의 element에 for문 내부에서만 사용하는 변수에 대입하는 방식으로
    index 넘버(주소지)의 사용없이 적용할 수 있는 for 반복문이 있는데,
    이를 향상된 for문이라고 합니다.

제약 : 읽기만 되고, 쓰기가 안됩니다.(1부터 100까지 추출하는 건 되는데 집어넣는 건 제한적으로 된다 등)

    형식 :
    for(자료형 변수명 : 반복가능객체(배열)) {
        반복실행문
    }

#### 일반 for문으로 자료 출력
```java
String[] names = {"김일", "김이", "김삼", "김사", "김오"};

for(int i = 0; i < names.length; i++) {
        System.out.print(names[i] + " ");
        }
```
#### 향상된 for문으로 element 출력 (대입은 x)
```java
for(String name : names) {
            System.out.print(name + " ");
        }
```
# 배열의 출력
엄밀히 말하자면 저희는 배열을 출력한게 아니라 여태까지 배열 내부의  element 들을 출력했습니다.
System.out.println(arr01); 과 같은 출력문을 작성했을 때
주소값만 나온다는 사실을 확인할 수 있습니다.

근데 element의 값을 조정하거나, 더하거나 같은 추가적인 가공을 하기 위해서 for 반복문을 사용해왔는데,
굳이 변형이 없고 배열 자체를 확인하고 싶을 때마다
main에 반복문을 작서하든지 method를 정의하든지 하는 일은 번거로운 일이 됩니다.

Arrays  클래스를 사용하고, '정적' 메서드인 , toString(배열명)을 사용하면
배열 전체를 출력할 수 있습니다.

여기서 우리는 클래스명.메서드명() 이라는 점에 주목할 필요가 있습니다.
scanner.nextLine()과는 다릅니다.

여기서 중요한 점은 동일한 method 명이라고 하더라도 어떤 클래스에 종속되어있는가에 따라
다른 결과값을 지닐 수 있다는 점입니다.
```java
// 동일한 메서드 명이지만 클래스에 따라 다른 로직일 수 있다는 예시
Random random = new Random();
Scanner scanner = new Scanner(System.in);
Random sc = new Random();       // 이클립스 사용시 Scanner sc = new Scanner(); sc라는 변수명을 사용하는 경우가 빈번
                                // 이렇게 사용하지 마세요.

int num1 = random.nextInt();
        System.out.println(num1);
        System.out.print("숫자를 입력하세요 >>> ");
int num2 = scanner.nextInt();
        System.out.println(num2);
```
int num1 = random.***nextInt();***
int num2 = scanner.***nextInt();***
nextInt()라는 동일한 메서드 명을 쓰지만 각각 Random, Scanner 클래스에 있기 때문에 다른 로직임

### 배열 출력 메서드
- Arrays.toString(배열명)
  - 예시 (int[]가 아닌 Integer로 선언한 이유 : Comparator.reverseOrder() 메서드를 쓰려면
    기본자료형(원시 자료형 / primitive type) int[] 배열을 사용할 수 없어서) ⬇️ 밑에 설명 있음
```java
Integer[] nums = {3, 6, 7, 1, 9, 2, 10, 5, 4, 8};
System.out.println(Arrays.toString(nums));
```
----
***정렬 메소드***
- Arrays.sort(배열명)       // 기본 오름차순
```java
Arrays.sort(nums); 
System.out.println("정렬 후 배열 : " + Arrays.toString(nums));
// 출력 : 정렬 후 배열 : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```
- Arrays.sort(배열명, Comparator.reverseOrder())   // 내림차순
```java
Arrays.sort(nums, Comparator.reverseOrder());
System.out.println("내림차순 정렬 후 배열 : " + Arrays.toString(nums));

// 출력 내림차순 정렬 후 배열 : [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
```
이상의 경우는 보면 sort() 메서드에 오름차순에서는 argument가 하나인데,
내림 차순 할 때는 보니까 argument가 두 개 입니다.
이상의 과정이 overloading이 이루어졌다는 점을 파악할 수 있으면 현재 수준으로는
만족스럽겠습니다.
그리고 두 번째 argument로 Comparator.reverseOrder();가 사용되었는데,
Comparator.reverseOrder()의 결과값 / return이 sort() 메서드의
두 번째argument로 사용되었다는 점에서 역시 함수형 프로그래밍의 일종이라고 볼 수 있겠네요.
근데 Comparator.reverseOrder() 메서드를 쓰려면
기본자료형(원시 자료형 / primitive type) int[] 배열을 사용할 수 없어서
Integer[] 배열을 사용하였는데, 현재는
char -> String 처럼 int -> Integer라고만 생각해두시면 되겠습니다.

# 2차원배열


: 다차원 배열은 2차원 이상의 배열을 의미하지만, 개발 환경 상

2차원 배경 이상을 다루는 경우는 극히 드물기 때문에 2차원 배열을 기준으로 강의합니다.

형식 :

    int [][] arr01 = new int[크기][크기];           - 선언 방식 #1
    int[][] arr02 = new int[크기][];              - 선언 방식 #2
    int[][] arr03 = {{1,2}, {3,4}, {5,6}}       - 선언 방식 #3 및 초기화

    2차원 배열 선언 시, 열의 크기는 지정하지 않아도 되지만, 행의 크기는 항상 지정해야 함.
        -> 2 번 방식에 해당합니다.
        1열 2열(colum)
          ↆ  ↆ
        { 1, 2 },    → 1 행(row)     가로줄을 '행'
        { 3, 4 },   →   2 행
        { 5 , 6 }   →   3 행

### 2차원 배열의 element 추출
1. 중첩 for문
```java
// 2차 배열의 element 추출 -> 중첩 for문을 사용하셔야 합니다.
        for(int i = 0; i < arr03.length; i++) {
            // 근데 반복문 하나 파고 들어가봐도 여전히 배열이기 때문에 이 부분에서 1차 배열을 추출하기 위한
            // 반복문을 추가로 작성해주셔야 합니다.
            for(int j = 0; j < arr03[i].length; j++) {  // arr03[i].length로 해야함
                System.out.println(arr03[i][j]);
            }
        }
```
2. 향상된 for문
 - 이중 향상된 for문 사용
```
for(int[] num : arr03) {
            for(int num1 : num) {
                System.out.print(num1 + " ");
            }
            System.out.println();
        }
```
 - 향상된 for문 내에 2차원 배열 출력 메서드 사용
```java
for(int[] firstArray : nums) {
            System.out.println(Arrays.toString(firstArray));
        }
```
### 2차원 배열 출력 메서드
- Arrays.deepToString(배열명)
```java
int[][] nums = new int[20][5]; // 1 ~ 100까지 들어가 있음
System.out.println(Arrays.deepToString(nums));
// 출력 [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20] ...]
```


추후 수업 예정
# 상속(Inheritance)
- 객체지향프로그래밍(OOP)의 핵심 개념 중 하나로, 기존 클래스 (부모(슈퍼) 클래스)의 field와 method를 재사용 하여
  새로운 클래스(자식(서브) 클래스)를 만드는 것을 의미함.

## 상속의 필요성
- 상속을 통해 공통적인 기능을 부모 클래스에 정의하고, 이를 '여러' 자식 클래스가 재사용 가능
  
  - 동물(Animal) 클래스가 있고, 이를 상속 받는 개(Dog) / 고양이(Cat) 클래스가 있다고 가정했을 때,
    동물의 공통적인 field(이름 / 나이 등) 와 행위(걷기 / 먹기 등)을 부모 클래스에 정의
    개와 고양이는 각각 고유한 특성(짖기 / 우다다다) 을 추가할 수 있음
  - 이상의 과정을 거쳤을 때 얻을 수 있는 이점 : Dog에 이름 / 나이 / 걷기 / 먹기 /  짖기를 정의하고
    또 Cat에다가 이름 / 나이 / 걷기 / 먹기 / 우다다다를 정의하는 등의 공통된 부분을 
  
    정의하는 일 없이 특정 field 및 메서드만 정의하면 됨. -> 중복된 코드를 줄일 수 있다.

## 상속의 특징
1. 단일 상속
   - Java는 단일 상속만 지원함. 하나의 클래스는 한 번에 하나의 부모 클래스만 상속 받을 수 있어 상속 구조가 간단하고 명확함.
2. super 키워드
   - 클래스의 생성자 및 setter에서 학습한 this와 유사한 개념으로
     부모 클래스의 field에 접근하거나 부모 클래스의 생성자를 호출할 때 사용함(두 가지 사용법이 있습니다.)
3. method override
  - 자식 클래스에서 부모 클래스의 기본 동작을 `'재정의'`할 수 있음. 이를 통해 자식 클래스는 부모 
    클래스의 기본 동작을 자신만의 방식으로 변경 가능
  - 예시
    - Animal클래스의 걷기를 Dog가 상속 받고, 네 발로 걷기로 _재정의_, Human 클래스가 걷기를
      상속 받고 두 발로 걷기로 _재정의_가 가능합니다.
final 키워드 - 클래스에 final이 붙으면 상속 불가
  - method에 final이 붙으면 메서드 오버라이딩 불가능

## 장점
1. 코드 재사용성 - 동일한 코드를 반복적으로 작성할 필요 x
2. 유지 보수의 용이성
   - 부모 클래스의 변경 사항이 자식 클래스에 자동으로 반영되기 때문에 위계 파악 후 수정하면 됩니다.
3. 객체 간 관계 표현 - IS-A 관계를 명확히 나타냄.
  - IS-A
    '개'는 '동물'의 일종이다. 와 같은 예시로, IS-A는 is a kind of의 축약어
  - 그래서 우리가 미리 만들어둔 Animal / Tiger / Human 의 클래스를 예로 들었을 때
    Human / Tiger는 Animal 클래스의 자식(서브) 클래스다.

# super 키워드
    1. super();   -> 얘는 부모 생성자를 호출한다는 의미
    2. super.메서드명();    -> 얘는 부모 클래스의 메서드를 호출한다는 의미

        지금 작성하는 부분의 경우 github에 완전판이 올라가기 때문에 왜 오류가 발생하는지
        어떻게 검증하는 지 어려움을 겪을 수 있습니다.

        부모 - 자식 상속관계가 성립되어 있을 때,
        부모 클래스에서 기본 생성자 없이 매개변수 생성자만 있다면
        자식 클래스에서 기본 생성자를 만들 수 없습니다.
        (Product의 기본생성자를 만드려고 하면 부모클래스인 Item의 AllArgsConstuctor가 생성)
        자식 클래스의 객체 생성 시 필수적으로 '부모 클래스의 생성자를 호출'하기 때문입니다.
        ↑ 이거 아래 예시 있음
        // 어떤 객체를 생성한다고 가정할 때
        A a = new B();
        같은 형태의 객체 생성 방식이 튀어나오게 되는데(추후 수업 예정)
        이상의 방식은 정보처리기사에서는 단골 문제입니다.
ch13_inheritance -> Product 클래스 확인 ‼️‼️ 하고 정리하기 ⭐⭐⭐⭐

```java
public class Product extends Item{
    // 자식 고유의 field 정의
    private int price;
    private int stock;

    // 자식 고유의 field에 대한 getter / setter 정의
    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    public int getStock() {
        return stock;
    }

    public void setStock(int stock) {
        this.stock = stock;
    }

    // 이거는 부모 생성자를 호출한건데 Product 클래스의 AllArgsConstuctor를 만들고 싶다면
    // alt + inset 눌러서 Product 클래스의 AllArgsConstuctor 선택한다면 부모 것을 자동으로 가져와서 생성자를 만듬
    public Product(String name, String category, int price, int stock) {
        super(name, category);
        this.price = price;
        this.stock = stock;


    }
    // 자동 완성 아닌 고유 메서드 하나 임의로 정의하겠습니다.
    public void showInfo() {
        System.out.println("제품명 : " +  this.getName());         // 부모거라서 getter로 조회  (여기 this는 시인성을 위해서 붙혀놈. 없으면 정적메서드라고 착각할 수도 있기 때문에 붙혀 놓는 것이 좋음)
        System.out.println("카테고리 : " +  this.getCategory());
        System.out.println("가격 : " +  price);       // 자식 거라서 field로 조회
        System.out.println("재고 : " +  stock);      // 두 줄씩 코드라인의 차이가 생기는 이유에 대해 명확히 아시길 추천드립니다.
    }

    public static void main(String[] args) {
        Product product = new Product("노트북", "가전", 10000, 1);
        product.showInfo();
    }
```
매개변수 - 오버로딩
재정의 - 오버라이딩