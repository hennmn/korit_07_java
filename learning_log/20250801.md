Method02 ~

// 근데 이렇게 method내에 sout 때렸을 때 문제가 뭐라고 했었죠?
데이터의 가공이 불가능 해서 return 형태로 만듦

### 별찍기 메서드를 만듬
```java
public static String getStar(int rows, int option) {
        // 메서드 내에서만 사용하는 지역 변수(local variable) 선언 및 초기화
        String result = "임시";
        
        if(option == 1) {       // 1. 왼쪽으로 치우친 증가하는 별
            for(int i = 0; i < (rows+1); i++) {
                for(int j = 0; j < i; j++) {
                    result += "*";
                }
                result += "\n";
            }
        } else if(option == 2) { // 2. 오른쪽으로 치우친 증가하는 별
            for(int i = 0; i < rows; i++) {
                // 공백 관련 for문
                for(int j = 0; j < rows - (i + 1); j++) {
                    result += " ";
                }
                //별찍기 관련 for문
                for(int k = 0; k < (i+1); k++) {
                    result += "*";
                }
                result += "\n";
            }
        } else if(option == 3) {    // 3. 왼쪽으로 치우친 감소하는 별
            for ( int i = 0 ; i < rows ; i++ ) {
                for ( int j = rows ; j > i ; j-- ) {
                    result += "😎";
                }
                result += "\n";
            }
        } else if(option == 4) {        // 4. 오른쪽으로 치우친 감소하는 별
            for(int i = 0; i < rows; i++) {
                // 공백을 책임지는 for문 -> 공백은 늘어나야 함.
                for(int j = 0; j < i +1; j++) {
                    result += " ";
                }
                // 별을 책임지는 for문 -> 별은 줄어들어야 함
                for(int k = rows; k > i; k--) {
                    result += "*";;
                }
                result += "\n";
            }
        } else {
            result = "해당 기능이 없습니다.";
        }

        return  result;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int rowOfStars = 0;
        int choice = 0;
        String starResult = "";

        System.out.println("몇 줄 짜리 별을 생성할까요? >>> ");
        rowOfStars = scanner.nextInt();

        System.out.println("1. 왼쪽으로 치우친 증가하는 별");
        System.out.println("2. 오른쪽으로 치우친 증가하는 별 ");
        System.out.println("3. 왼쪽으로 치우친 감소하는 별");
        System.out.println("4. 오른쪽으로 치우친 감소하는 별");
        System.out.println("선택하세요 >>>> ");
        choice = scanner.nextInt();

        starResult = getStar(rowOfStars,choice);

        System.out.println(starResult);

```
### 위의 코드처럼 굳이 main에서 scanner를 받지 않고 메서드로 다 올려버리면 더 깔끔하지 않을까?
*** method 내부에서 method를 호출하는 것이 가능 ***
```java
    public class Method03 {

    public static String getStar() {
        String result = "";
        // method 내부에서 method를 호출하는 것이 가능합니다.

        // Method02에서 main 단계에 써둔 부분을 여기에 다 가지고 오면
        //getStar() 메서드를 호출하는 것만으로도 동일한 결과값이 나오지 않을까요

        Scanner scanner = new Scanner(System.in);
        int rows = 0;
        int option = 0;
        System.out.println("몇 줄 짜리 별을 생성하시겠습니까?");
        rows = scanner.nextInt();
        System.out.println("1. 왼쪽으로 치우친 증가하는 별");
        System.out.println("2. 오른쪽으로 치우친 증가하는 별 ");
        System.out.println("3. 왼쪽으로 치우친 감소하는 별");
        System.out.println("4. 오른쪽으로 치우친 감소하는 별");
        System.out.println("선택하세요 >>>> ");
        option = scanner.nextInt();

        if(option == 1) {       // 1. 왼쪽으로 치우친 증가하는 별
            for(int i = 0; i < (rows+1); i++) {
                for(int j = 0; j < i; j++) {
                    result += "*";
                }
                result += "\n";
            }
        } else if(option == 2) { // 2. 오른쪽으로 치우친 증가하는 별
            for(int i = 0; i < rows; i++) {
                // 공백 관련 for문
                for(int j = 0; j < rows - (i + 1); j++) {
                    result += " ";
                }
                //별찍기 관련 for문
                for(int k = 0; k < (i+1); k++) {
                    result += "*";
                }
                result += "\n";
            }


        } else if(option == 3) {    // 3. 왼쪽으로 치우친 감소하는 별
            for ( int i = 0 ; i < rows ; i++ ) {
                for ( int j = rows ; j > i ; j-- ) {
                    result += "😎";
                }
                result += "\n";
            }

        } else if(option == 4) {        // 4. 오른쪽으로 치우친 감소하는 별
            for(int i = 0; i < rows; i++) {
                // 공백을 책임지는 for문 -> 공백은 늘어나야 함.
                for(int j = 0; j < i +1; j++) {
                    result += " ";
                }
                // 별을 책임지는 for문 -> 별은 줄어들어야 함
                for(int k = rows; k > i; k--) {
                    result += "*";;
                }
                result += "\n";
            }
        } else {
            result = "해당 기능이 없습니다.";
        }

        return result;
    }
    public static void main(String[] args) {
        // 이건 너무 잡다함
//    String starResult =  "";
//    starResult = getStar();
//    System.out.println(starResult);
    
      System.out.println(getStar());  // 메서드 호출 결과를 print

    }
```
****

1. 클래스란?
   객체를 생성하기 위한 설계도 = 틀 / 청사진.
   현실 세계의 개념을 프로그래밍으로 표현할 때,
   "특정 사물이나 개념의 특징(속성)"과 "행위(메서드)"로 정의함
   예를 들어,
   "자동차"라는 클래스를 생성한다면 자동차의 속성(색상, 속도)과,
   행동(가속, 정지 등)을 코드로 표현할 수 있음

2. 객체(Object) 란?
   클래스를 설계도로 가정했을 때, 실제 사용할 수 있는 자동차(인스턴스)는 객체라고 함.

   여기서 Object와 Istance라는 표현은 우리나라에서는 거의 동일합니다.

   객체와 인스턴스의 관계
   객체는 포괄적인 개념으로 클래스에서 생성된 모든 것을 객체라고 표현,
   인스턴스는 특정 객체가 어떤 클래스의 구현체인지를 강조하는 표현

   비유로 이해하기
   클래스 : 설계도
   객체 : 설계도를 바탕으로 만들어진 모든 실물
   인스턴스 : 특정 설계도를 기반으로 만들어진 "해당 실물"

   예를 들어,
1. "사람"이라는 클래스를 고려할 때,
2. "홍길동", "김철수"는 클래스에서 생성된 객체임. 근데 "아반떼"도 객체긴 함.
3. "홍길동"은 "사람"이라는 특정 클래스의 '인스턴스'에 해당

#### 객체 생성(main영역 밖에서 실행)
ClassA classA1 = new ClassA();
Scanner scanner = new Scanner(System.in);

이미 객체의 메서드(기능)을 호출했었음.
scanner.nextLine();

클래스에 선언된 변수들에 값 대입
객체명.속성명 = 데이터;
classA1.num = 1;
classA1.name = "김일";
classA1.score = 4.2;

#### 메서드 호출 방법(main영역에서 실행)
객체명.메서드명();
classA1.callName();  // scanner.next();와 같은 방식이죠


# method overloading
매개변수의 유무 및 자료형의 차이, 개수의 차이를 나눠서 동일한 메서드 명을 지닌 메서드들을 정의할 수 있다.

즉, 메서드명은 동일하고, 매개변수에 들어가는 자료형, 갯수를
달리하게 되면 서로 다른 메서드로 받아들임.

#### overlaoding의 장점 :
동일한 기능을 하는 메서드를 정의할 때 메서드 명이 필요한데, 
예를 들어 String 자료형끼리 연결해주는 메서드와 int 끼리의 합 연산을 하는 메서드를 나눈다고 가정했을 때
add, plus, connect등의 메서드를 정의했다면
다음 합 연산을 하는데(예를 들어 double 자료형을 지니는)메서드 명을 정하는 것이 번거롭다.

```java
public void add(String example, String example2) {
                로직
            }
            public void add(int example1, int example2) {
                로직
               }
            public void add(String example, String example2, String example3) {
                로직
            }
```
와 같은 식으로 메서드 명을 동일하게 가져가면서 차이를 둘 수 있습니다.
머리가 아프지 않다는 장점이 있습니다.

```java
// overlaoding 적용
    // call2 유형으로 정의
    public static void add(String s) {
        System.out.println("add(String s)");
        System.out.println(s);
    }

    // call2() 유형으로 작성 #2
    public static void add(int a, int b) {
        System.out.println("add(int a, int b)");    // 사실 얘랑
        System.out.println(a + b);                  // 얘는 overloading의 결과물이겠네요.
    }

    public static void add(int a, String s) {
        System.out.println("add(int a, String s)");
        System.out.println(a + " / " + s);
    }

    public static void add(String s, int a) {
        System.out.println("add(String s, int a)");
        System.out.println(a + " / " + s);
    }

    public  static void add(int a, int b, double c) {
        System.out.println("add(int a, int b, double c)");
        System.out.println("a + b + c = " + (a + b + c));
    }

    public static void main(String[] args) {
        // 메서드 호출 영역
        add();
        add("안녕하세요");
        add(1,2);
        add(8,"월 1일");      // Java는 매개변수 순서가 매우 중요해서 얘랑
        add("월 1일", 8);     // 얘가 다른 메서드로 정의됨
        add(1,2,4.5);

    }
```
```java
public class Constructor {
    // 필드 선언
    int num;
    String name;
```

## 생성자(Constructor)
생성자는 객체가 생성될 때 호출되는 특별한 '메서드'

        객체 생성 예시
        클래스명        객체명 = new 클래스명();
        ClassExample example = new ClassExample();
        : 사실 ClassExample() -> 생성자에 해당합니다.

        특징 :
            1. **클래스의 이름**과 생성자의 이름은 **동일**하다. 
                (다른 메서드들과 달리 대문자로 시작한다.) 클래스 이름과 동일하기 때문
            2. return 값이 없다. -> 즉, call1() / call2() 유형으로 생각할 수 있습니다.
            3. 객체 초기화 : 생성자는 객체의 필드 '초기화'를 담당한다.

        생성자의 정의 방식
            1. 기본 생성자 : 매개변수가 없는 생성자 -> 원래 기본적으로 만들어짐
                (사실 클래스를 만들 때 default로 생성되는 형태로 정의하지 않아도 될 때가 있음)
                그래서 ClassA, Car에서 기본 생성자를 정의하지 않고
                CalssAMain, CarMain에서 객체를 생성해봤었습니다. -> 복습 필요
                    정확하게는 default 로 생성된 기본 생성자를 Main 에서 호출했다고 볼 수 있습니다.
                    호출 결과 -> 객체 생성
                    ex_ Class class = new Class();  -> Class(); 이 부분으로 기본 생성자 호출
            2. 매개변수 생성자 : 하나 이상의 매개 변수를 가지는 생성자  
                                -> 기본적으로 만들어지지 x (개발자가 정의해야 함)
                매개변수 생성자가 하나라도 만들어지면 default로 만들어진 기본 생성자가 사라지기 때문에
                기본생성자와 매개변수 생성자를 둘 다 사용하고 싶다면 
                기본 생성자도 따로 '명시적으로 정의' 해야만 합니다.
    

*** 생성자 자동 단축키 ***
alt + insert

***

# 생성자 관련 정리(롬복)
1. NoArgsConstructor - 기본생성자
2. RequiredArgsConstructor - 매개변수 생성자
3. AllArgsConstructor - 클래스의 전체 필드를 전부 요구하는 매개변수 생성자

금일 복습
method 구현 관련 정리 / 클래스 개념 - 구성 요소 / 생성자 관련 부분을 정리하시면 되겠습니다.
프로필에 정보


다음주 월요일 수업 계획
1. 클래스 / 생성자 관련 복습
2. getter / setter
3. access modifier(접근지정자)
4. 진짜 빨리 나가면 배열

8월 24일까지 카페 가입 및 이력서 초안 작성

ch09_classes -> products
Product / ProductMain 생성

