# 전체 복습(쉬운 버전)
ch11_access_modifier -> CharacterMain클래스 생성

# 금일 수업 계획
1. 배열(Array)
2. 천천히 한다
3. 복습도 한다
4. 금일 이름 역순 면담

# 접근 지정자 추가 설명 
## public -> 모든 곳에서 접근이 가능
    1. 완전히 공개된 상태
    2. 누구든지 사용 가능
    3. 보통 라이브러리나  API의 공개된 기능에 사용됨.
```java
public class Car {
    // 필드 선언 및 초기화
    public  String model = "셀토스";
    
    //메서드 정의
    public void drive() {
        System.out.println("자동차를 운전합니다.");
    }
}
```
이상의 코드는 다른 어떤 클래스를 생성하더라도 경로만 정확하다면 Car car1 = new Car(); 로
객체를 생성할 수 있고(class가 public이니까), System.out.println(car1.model); 이라고 했을 때
'셀토스' 라는 String 데이터가 콘솔에 찍힐겁니다(field가  public 이니까). 마지막으로 car.drive();
를 호출해도 콘솔에 "자동차를 운전합니다." 라는 텍스트가 콘솔에 나올겁니다.(method가 public이니까).

## private -> 자기 클래스 내부에서만 접근 가능
1. 가장 제한적인 접근 지정자
2. 클래스 외부에서 전혀 접근할 수 없음
3. 데이터 보호 목적으로 사용
```java
public class Car {
    private String engine = "V6";

    public void showEngine() {
        System.out.println("엔진 정보 : " + engine);
    }
}
// 별개의 클래스
public class CarMain {
    public static void main(String[] args) {
        //객체 생성
        Car car1 = new Car();
        System.out.println(car1.engine);    // 컴파일링 오류 : 필드 자체는 private
        car1.showEngine();      // 엔진 정보 : V6 이라고 출력됨 -> method 는 public이기 때문에
    }


}

```
Car를 기준으로 field는 private / 일부 정보만 공개하게 되는 method는 public이기 때문에 CarMain에서 객체를
생성하는 것 가능(class level - public)
엔진 정보를 직접 조회하는 것(car1.engine)은 불가능 field는 private이니깐
하지만 method를 경유하여 조회하는 것은 가능(car.showEngine()) - method는 public이니까.

## protected -> 같은 패키지 + 상속(추후 수업)관계에서 접근 가능
기본적으로 추후에 배울 default와 같지만 자식 클래스에서 상속 받아서 사용 가능
```java
package vehicle;

public class Car{
    protected String brand = "기아";
    
    
}
// 같은 패키지의 다른 클래스
pakage vehicle;

import vehicle.Car;

public class MyCar extends Car {        //extends는 상속 관계를 나타내는 키워드
    public void showBrand() {
        System.out.println(brand);
    }
}

```
추후 상속 개념을 학습했을 때 더 자세히 알 수 있지만 Car클래스의 protected 필드인
brand를 동일한 패키지의 MyCar클래스에서 '직접 조회' 했습니다.(Getter와 같은 메서드를 경유한 것이 아니라.)

## (default) - 아무 접근 지정자도 없을 때 (pakage - private)
1. 같은 패키지 안에서는 접근 가능, 다른 패키지에서는 불가능
```java
class Car {
    String color = "red";
    
}
```
이상의 경우, class 레벨도 default / field 레벨도 default라고 볼 수 있습니다.
그리고 저희는 여태까지 챕터 단위로 패키지를 만들었고 그 안에서 객체 생성을 했었기 때문에
ch08_methods  이후로 별 문제 없이 패키지 내에서 클래스를 만들고
(Car / CarMain)을 만들고. 객체를 생성하고, 필드도 조회하고, 메서드도 호출가능했었습니다.

앞으로의 수업부터는 접근 지정자를 분명하게 명시하여 개발자인 여러분들이 직접 통제하도록
진행될 예정입니다.

## 실무적인 관점에서의 접근 지정자 선택
1. 필드는 원칙적으로 -> private
2. 메서드는 외부 공개 필요시 -> public
3. 상속 대상 메서드 -> protected
4. 패키지 내부에서만 쓰이는 도우미 클래스 -> (default)

### 항상 그런 것은 아니지만 염두해두면 좋은 부분
1. 필드는 웬만하면 private로 지정하고, 접근은 getter / setter 를 통하자(자동완성이 public인 이유)
2. 인터페이스나 라이브러리는 public을 최소화할 것. 이미 공개된 API는 되돌리기 어려움
   - 다른 회사가 내가 만든 class를 쓰고 있는데 멀쩡하게 public으로 되어있던게 default로 바뀌게 되면
     그 회사는 더 이상 제가 만든 class를 사용하지 못하게 될거고, 기존 로직을 다 갈아 엎어야 할겁니다.

## 작성가이드
목표 : 객체 지향 설계 및 접근 지정자 이해를 바탕으로
다양한 접근 수준의 필드와 메서드를 갖는 캐릭터 클래스를 정의하고
이를 CharacterMain  클래스에서 기능 테스트를 수행할 겁니다.

    클래스 설계
    1. 필드
    name -> 캐릭터 이름(공개가능)
    health - 체력 -> 읽기만 허용
    power - 공격력 -> 같은 패키지만
    skill - 스킬이름 -> 자식 클래스만
    exp - 경험치 -> 외부에서 완전 차단(읽기만 허용이랑 유사)

    Character 클래스의 인스턴스인 warrior를 생성하고
    이름 전사
    체력 100
    공격력 200
    스킬 세로베기
    exp 30
    으로 기본 생성자를 통해 생성하고, setter를 통해서 데이터를 집어넣으시오.

    2. 메서드 정의
    getHealth() -> 체력값을 반환하는 getter -> public / 이미 자동완성으로 만들었습니다.
    attack() -> 공격 시 콘솔 창에
            name 이 power로 공격 !
            name 이(가) 경험치 amount을(를) 얻었습니다. -> 라고 두 줄 출력되게 작성할 것.call1() 유형
     heal() -> 체력을 10 회복하고, 현재 체력 출력
                체력이 10 회복되었습니다. 현재 체력 : healeth(숫자로 출력돼야 합니다.)
     gainExp(int amount) -> call2() 유형이고 경험치를 증가시키는 메서드(내부 전용)
        실행 예
        name이(가) 경험치 amount을(를) 얻었습니다.
```java
class Character {
    public String name;             // 공개 가능 이니까
    private int health;              // 읽기만 허용
    int power;                      // 같은 패키지만
    protected String skill;         // 자식 클래스만
    private int exp;               // 완전 차단

    

    // 밑에 매개변수를 받는 생성자가 있어서 기본 생성자는 무조건 명시해야 함
    public Character() {
    }
    // 생성자(캐릭터 생성시에 필수적으로 요구되는 애들만 매개변수로 받은 매개변수 생성자)
    public Character(String name, int power, String skill) {
        this.name = name;
        this.power = power;
        this.skill = skill;

        this.health = 100;  // 초기 체력(매개변수는 없죠. 객체 생성시에 무조건 체력 100으로 고정된다는 의미)
        this.exp = 0;

    }

    // Setter
    public void setName(String name) {
        this.name = name;
    }

    public void setHealth(int health) {
        this.health = health;
    }

    public void setPower(int power) {
        this.power = power;
    }

    public void setSkill(String skill) {
        this.skill = skill;
    }

    public void setExp(int exp) {
        this.exp = exp;
    }

    
    // Getter
    public String getName() {
        return name;
    }

    public int getHealth() {
        return health;
    }

    public int getPower() {
        return power;
    }

    public String getSkill() {
        return skill;
    }

    public int getExp() {
        return exp;
    }

    // attack()
    public void attack() {
        System.out.println(name + "이(가) " + power + "의 힘으로 공격합니다 !");;
        // 공격하고 나서 경험치를 얻고 싶습니다. -> 그런데 외부에서 공격 이외의 방식으로 경험치를 강제적으로
        // 획득하는 버그는 막고 싶어요. 그렇다면 위의 가이드에서 작성했던 gainExp()는 외부에서 실행되면 안됩니다.
        this.gainExp(30);  // 여기 있는 건 공격할 때 마다 30으로 고정된 것임
    }

    private void gainExp(int amount) {
        exp += amount;
        System.out.println(name + "이(가) " + amount + " 얻었습니다.");

    }

    public  void heal() {
        health += 10;
        System.out.println(name + "의 체력이 회복되었습니다. 현재 체력 : " + health);
    }


}

public class CharacterMain {
    public static void main(String[] args) {
        Character warrior = new Character("전사",200,"세로베기");
//        이름 전사
//        체력 100
//        공격력 200
//        스킬 세로베기
//        exp 30
//        warrior.name = "전사";    // field 가 public이기 때문에 타 클래스인 CharacterMain에서 값을 직접 대입하는 것이 가능
//        warrior.setName("전사");      // 이상의 직접 대입 방식과의 코드 작성 차이점에 대해서 확인하시기 바랍니다.
//        warrior.setHealth(100);
//        warrior.setPower(200);
//        warrior.setSkill("세로베기");
//        warrior.setExp(30);
        System.out.println(warrior.getHealth());

        // warrior.gainExp(1000);   -> gainExp()를 private 처리했기 때문에 오류 발생
        warrior.attack();
        warrior.heal();
        /*
            이상의 코드에서 여러분들이 중점적으로 학습해야 할 점은
            접근 지정자의 설정 수준에 따라서 setter / getter가 필요한 사례가 있고 아닌 사례가 있다는 점입니다.
            예를 들어 게임을 하거나 SNS를 한다고 쳤을 때 닉네임의 경우는 누구나 볼 수 있죠.
            그렇다면 닉네임 필드는 public으로 설정되어있을겁니다.
            그렇기 때문에 getter를 통한 닉네임 호출은 필요가 없어서 이상의 코드에서 getName() 메서드는 쓸모가 없을 겁니다.

            우리는 어떤 클래스/필드/메서드를 어떤 접근지정자를 설정해야할지도 고민해야겠습니다.

            하지만 현재 수업 상황에서는 웬만하면 필드는 private로 설명, getter / setter 를 통한 우회 설명 및 조회를
            목표로 하겠습니다.
         */
    }
}
```
## 알게된 거 !
    - health, exp 같은 경우 읽기만 허용이라서 어떻게 해야 하나 싶었는데
      생성자에 넣을 수 있다는 걸 알게됨
    - gainExp를 외부에서 가져오지 않고 어떻게 증가시키나 했는데
      private gainExp() 메서드 선언 하고 attack() 에서 gainExp(30) 으로 고정해서
      불러올 수 있다는 걸 알게됨 
     
# 배열(Array)
## 배열의 필요성
여태까지의 수업을 기준으로 하면 10개의 정수형 데이터를 저장하려면 int 변수를 10개 선언해서 저장해야 합니다.
배열은 '같은' 자료형의 데이터를 하나의 변수에 저장해서 관리하는 방식입니다. -> Java에서 입니다.
즉 113번 라입과 같은 상황에서 하나의 변수만 가지고 내부에 10개의 int 데이터를 저장할 수 있음을 뜻합니다.
 - 파이썬은 리스트에 다양한 자료형의 변수 저장 가능

## 선언 방식
자료형[] 변수명
```java
형식 : 
자료형 [] 변수명 = 데이터;
int [] arr01 = {1 ,2, 3, 4, 5}; // 그럼 얘는 변수 선언 및 초기화에 해당하겠네요.
int[] arr02 = new int[10];


```


